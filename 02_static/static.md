# static

当与不同类型一起使用时，Static关键字具有不同的含义。我们可以使用static关键字：

+ 静态变量： 函数中的变量，类中的变量

+ 静态类的成员： 类对象和类中的函数

## 1.静态变量

### 1.1 函数中的静态变量

> 当变量声明为static时，空间将在**程序的生命周期内分配**。**即使多次调用该函数，静态变量的空间也只分配一次，前一次调用中的变量值通过下一次函数调用传递。**这对于在C / C ++或需要存储先前函数状态的任何其他应用程序非常有用。

```cpp
static int count = 0; 	//第二次调用这个语句时候，也不会重新赋值0
```

变量count被声明为static。因此，它的值通过函数调用来传递。每次调用函数时，都不会对变量计数进行初始化。

### 1.2 类中的静态变量

> 由于**声明为static的变量只被初始化一次**，因为它们在单独的静态存储中分配了空间，因此**类中的静态变量由对象共享**。**对于不同的对象，不能有相同静态变量的多个副本。也是因为这个原因，静态变量不能使用构造函数初始化**。

**类中的静态变量应由用户使用类外的类名和范围解析运算符显式初始化**

```cpp
#include<iostream> 
using namespace std; 

class Apple 
{ 
public: 
    static int i; 

    Apple() 
    { 
        // Do nothing 
    }; 
}; 

int Apple::i = 1; 

int main() 
{ 
    Apple obj; 
    // prints value of i 
    cout << obj.i; 
} 
```

## 2. 静态类中的成员

### 2.1类对象为静态

> 就像变量一样，对象也在声明为static时具有范围，直到程序的生命周期。

```cpp
int main() 
{ 
    int x = 0; 
    if (x==0) 
    { 
        Apple obj; 
    } 
    cout << "End of main\n"; 
} 
//对于非静态的对象，在if结束之后就调用了析构函数，对象就被释放了

int main() 
{ 
    int x = 0; 
    if (x==0) 
    { 
        static Apple obj; 
    } 
    cout << "End of main\n"; 
} 
//对于静态对象，先结束main函数，才调用析构函数释放对象
//静态对象的范围是贯穿程序的生命周期。
```

### 2.2类中的静态函数

+ 就像类中的静态数据成员或静态变量一样，静态成员函数也不依赖于类的对象。

+ 允许静态成员函数仅访问静态数据成员或其他静态成员函数，它们**无法访问类的非静态数据成员或成员函数**。

